/*
 * Created on $today.date ( Time $today.time )
 * Generated by $generator.name ( version $generator.version )
 */
#set ( $uncapitalizedEntityName = ${fn.uncapitalize($entity.name)})
##
#set ( $sqlFindAttribs = "" )
#set ( $sqlUpdateAttribs = "" )
#set ( $sqlCreateAttribs = "" )
#set ( $modelRows = "" )
#set ( $sqlInsertValues = "" )
#set ( $sqlInsertValuesWithId = "" )
#set ( $sqlRequestAttribs = "" )
#set ( $sqlParamsAttribs = "" )
#set ( $sqlRequest2CreateAttribs = "" )
#set ( $sqlPrimaryKeyParams = "" )
#set ( $sqlKeyParams = "" )
##
#foreach( $attrib in $entity.attributes )
#if ( $foreach.count > 1 )
#set ( $sqlFindAttribs = $sqlFindAttribs + ", " )
#end
#set ( $sqlFindAttribs = $sqlFindAttribs + """${fn.uncapitalize($attrib.name)}""" )
#end
##
#foreach( $attrib in $entity.attributes )
#if ( !$entity.keyAttributes.contains($attrib) )
#if ( !$sqlUpdateAttribs.equals("") )
#set ( $sqlUpdateAttribs = $sqlUpdateAttribs + ", " )
#end
#set ( $sqlUpdateAttribs = $sqlUpdateAttribs + """${fn.uncapitalize($attrib.name)}""" )
#set ( $sqlUpdateAttribs = $sqlUpdateAttribs + "=:${fn.uncapitalize($attrib.name)}" )
#end
#end
##
#foreach( $attrib in $entity.attributes )
#if ( !$entity.keyAttributes.contains($attrib) )
#if ( !$sqlCreateAttribs.equals("") )
#set ( $sqlCreateAttribs = $sqlCreateAttribs + ", " )
#end
#set ( $sqlCreateAttribs = $sqlCreateAttribs + ${fn.uncapitalize($attrib.name)} )
#end
#end
##
#foreach( $attrib in $entity.attributes )
#if( $foreach.count > 1 )
#set ( $modelRows = $modelRows + ", " )
#end
#set ( $modelRows = $modelRows + "row." )
#set ( $modelRows = $modelRows + ${fn.uncapitalize($attrib.name)} )
#end
##
#set ( $insertCpt = 0 )
#foreach( $attrib in $entity.attributes )
#if ( !$entity.keyAttributes.contains($attrib) )
#set ( $insertCpt = $insertCpt +1 )
#if ( $insertCpt > 1 )
#set ( $sqlInsertValues = $sqlInsertValues + ", " )
#end
#set ( $sqlInsertValues = $sqlInsertValues + ":"+${fn.uncapitalize($attrib.name)} )
#end
#end
##
#foreach( $attrib in $entity.attributes )
#if ( $foreach.count > 1 )
#set ( $sqlInsertValuesWithId = $sqlInsertValuesWithId + ", " )
#end
#set ( $sqlInsertValuesWithId = $sqlInsertValuesWithId + ":"+${fn.uncapitalize($attrib.name)} )
#end
##
#foreach ( $key in $entity.keyAttributes )
#if ( $foreach.count > 1 )
#set ( $sqlRequestAttribs = $sqlRequestAttribs + " AND " )
#end
#set ( $sqlRequestAttribs = $sqlRequestAttribs + """${fn.uncapitalize($key.name)}""" )
#set ( $sqlRequestAttribs = $sqlRequestAttribs + "=:${fn.uncapitalize($key.name)}" )
#end
##
#foreach ( $key in $entity.keyAttributes )
#if ( $foreach.count > 1 )
#set ( $sqlParamsAttribs = $sqlParamsAttribs + ",
			" )
#end
#set ( $sqlParamsAttribs = $sqlParamsAttribs + "${fn.uncapitalize($key.name)}: ${fn.uncapitalize($key.name)}" )
#end
##
#foreach ( $key in $entity.keyAttributes )
#if ( $foreach.count > 1 )
#set ( $sqlKeyParams = $sqlKeyParams + "," )
#end
#set ( $sqlKeyParams = $sqlKeyParams + """${fn.uncapitalize($key.name)}""" )
#end
##
#foreach ( $key in $entity.keyAttributes )
#if ( $foreach.count > 1 )
#set ( $sqlRequest2CreateAttribs = $sqlRequest2CreateAttribs + " AND " )
#end
#set ( $sqlRequest2CreateAttribs = $sqlRequest2CreateAttribs + ${fn.uncapitalize($key.name)} )
#set ( $sqlRequest2CreateAttribs = $sqlRequest2CreateAttribs + "=:id" )
#end
##
#foreach ( $key in $entity.keyAttributes)
#set ( $uncapitalizedKeyName = ${fn.uncapitalize($key.name)})
#if ($foreach.count < $entity.keyAttributes.size())
#set ( $sqlPrimaryKeyParams = $sqlPrimaryKeyParams + "${uncapitalizedKeyName} : ${entity}.${uncapitalizedKeyName}, 
            ")
#else
#set ( $sqlPrimaryKeyParams = $sqlPrimaryKeyParams + "${uncapitalizedKeyName} : ${entity}.${uncapitalizedKeyName}")
#end
#end

// Load ${entity.name} entity
const ${entity.name} = require('../model/${entity.name}');

// Load DAO Common functions
const GenericDao = require('./commons/genericDao');

// SQL Queries
const sqlSelectById = 'SELECT $sqlFindAttribs FROM "$uncapitalizedEntityName" WHERE $sqlRequestAttribs';
const sqlSelectAll = 'SELECT * FROM "$uncapitalizedEntityName"';
const sqlCount = 'SELECT COUNT(*) AS count FROM "$uncapitalizedEntityName"';
const sqlUpdate = 'UPDATE "$uncapitalizedEntityName" SET $sqlUpdateAttribs WHERE $sqlRequestAttribs RETURNING $sqlKeyParams';
const sqlDelete = 'DELETE FROM "$uncapitalizedEntityName" WHERE $sqlRequestAttribs RETURNING $sqlKeyParams';
const sqlExist = 'SELECT (count(*) > 0) as found FROM "$uncapitalizedEntityName" WHERE $sqlRequestAttribs';
#if ($entity.hasAutoIncrementedKey())
const sqlInsert = 'INSERT into "$uncapitalizedEntityName" ($sqlCreateAttribs) VALUES ($sqlInsertValues) RETURNING $sqlKeyParams';
#else
const sqlInsert = 'INSERT into "$uncapitalizedEntityName" ($sqlFindAttribs) VALUES ($sqlInsertValuesWithId) RETURNING $sqlKeyParams';
#end

/**
 * DAO of entity ${entity.name}
 */
module.exports = class ${entity.name}Dao {

    constructor() {
        this.genericDao = new GenericDao(
            sqlSelectById,
            sqlSelectAll,
            sqlCount,
		    sqlInsert,
            sqlUpdate,
            sqlDelete,
            sqlExist
        );
    }

    /**
     * Tries to find an entity using its Id / Primary Key
     * @param $fn.argumentsList($entity.keyAttributes)
     * @return entity
     */
    findById($fn.argumentsList($entity.keyAttributes)) {
       let sqlParams = {
			$sqlParamsAttribs
		};
        return this.genericDao.findOne(sqlParams)
            .then(row => {
                if(row) {
                    return new ${entity.name}($modelRows);
                } else {
                    return false;
                }
            })
    };

    /**
     * Finds all entities.
     * @return all entities
     */
    findAll() {
        return this.genericDao.findAll().then(rows => {
            let ${uncapitalizedEntityName}s = [];
            if (rows) {
                for (const row of rows) {
                    ${uncapitalizedEntityName}s.push(new ${entity.name}($modelRows));
                }
            }
            return ${uncapitalizedEntityName}s;
        });
    };

    /**
     * Counts all the records present in the database
     * @return count
     */
    countAll() {
        return this.genericDao.findOne();
    };

    /**
     * Updates the given entity in the database
     * @param ${entity.name}
     * @return true if the entity has been updated, false if not found and not updated
     */
    update(${entity.name}) {
        let sqlParams = {
#set ( $saveUpdateBodyReturn = "")
#foreach ( $attrib in $entity.attributes)
#set ( $uncapitalizedAttribName = ${fn.uncapitalize($attrib.name)})
#if ($foreach.count < $entity.attributes.size())
#if ( $attrib.isDateType() )
#set ( $saveUpdateBodyReturn = $saveUpdateBodyReturn + "${uncapitalizedAttribName}: new Date(${entity}.${uncapitalizedAttribName}).toISOString(),
                                ")
 			${uncapitalizedAttribName}: new Date(${entity.name}.${uncapitalizedAttribName}).toISOString(),
#else
#set ( $saveUpdateBodyReturn = $saveUpdateBodyReturn + "${uncapitalizedAttribName}: ${entity}.${uncapitalizedAttribName},
                                ")
 			${uncapitalizedAttribName}: ${entity.name}.${uncapitalizedAttribName},
#end
#else
#if ( $attrib.isDateType() )
#set ( $saveUpdateBodyReturn = $saveUpdateBodyReturn + "${uncapitalizedAttribName}: new Date(${entity}.${uncapitalizedAttribName}).toISOString()")
 			${uncapitalizedAttribName}: new Date(${entity.name}.${uncapitalizedAttribName}).toISOString()
#else
#set ( $saveUpdateBodyReturn = $saveUpdateBodyReturn + "${uncapitalizedAttribName}: ${entity}.${uncapitalizedAttribName}")
 			${uncapitalizedAttribName}: ${entity.name}.${uncapitalizedAttribName}
#end
#end
#end
        };
        return this.genericDao.update(sqlParams);
    };

    /**
     * Save the given entity in the database in case it exist, else create a new one
     * @param ${entity.name}
     * @return the updated or created entity
     */
    save(${entity.name}) {
        return this.exists(${entity.name}).then(exist => {
            if(exist) {
                return this.update(${entity.name}).then(result => {
                    if (result === true) {
                        return {
                            body: {
                                 $saveUpdateBodyReturn
                             },
                            newItem: false
                        };
                    } else {
                        return result;
                    }
                });
            } else {
                return this.create(${entity.name}).then(result => {
                    if (result) {
                        return {
                            body: result,
                            newItem: true
                        };
                    } else {
                        return result;
                    }
                });
            }
        });
    };

    /**
     * Creates the given entity in the database
     * @param ${entity.name}
     * returns database insertion status
     */
    create(${entity.name}) {
        let sqlParams = {
#if ($entity.hasAutoIncrementedKey())
#foreach ( $attrib in $entity.nonKeyAttributes)
#set ( $uncapitalizedAttribName = ${fn.uncapitalize($attrib.name)})
#if ($foreach.count < $entity.nonKeyAttributes.size())
#if ($attrib.isDateType())
 			${uncapitalizedAttribName}: new Date(${entity}.${uncapitalizedAttribName}).toISOString(),
#else
 			${uncapitalizedAttribName}: ${entity}.${uncapitalizedAttribName},
#end
#else
#if ($attrib.isDateType())
 			${uncapitalizedAttribName}: new Date(${entity}.${uncapitalizedAttribName}).toISOString()
#else
 			${uncapitalizedAttribName}: ${entity}.${uncapitalizedAttribName}
#end
#end
#end
#else
#foreach ( $attrib in $entity.attributes)
#set ( $uncapitalizedAttribName = ${fn.uncapitalize($attrib.name)})
#if ($foreach.count < $entity.attributes.size())
#if ($attrib.isDateType())
 			${uncapitalizedAttribName}: new Date(${entity}.${uncapitalizedAttribName}).toISOString(),
#else
 			${uncapitalizedAttribName}: ${entity}.${uncapitalizedAttribName},
#end
#else
#if ($attrib.isDateType())
 			${uncapitalizedAttribName}: new Date(${entity}.${uncapitalizedAttribName}).toISOString()
#else
 			${uncapitalizedAttribName}: ${entity}.${uncapitalizedAttribName}
#end
#end
#end
#end
        };

        return this.genericDao.insert(sqlParams)
            .then(result => {
                if (result) {
                    return {
#foreach ( $attrib in $entity.attributes)
#set ( $uncapitalizedAttribName = ${fn.uncapitalize($attrib.name)})
#if (!$attrib.isAutoIncremented())
#if ($attrib.isDateType())
 					    ${uncapitalizedAttribName}: new Date(${entity}.${uncapitalizedAttribName}).toISOString()#if($foreach.count < $entity.attributes.size()),#else#end

#else
 					    ${uncapitalizedAttribName}: ${entity}.${uncapitalizedAttribName}#if($foreach.count < $entity.attributes.size()),#else#end

#end
#else
 					    ${uncapitalizedAttribName}: result.${attrib.name}#if($foreach.count < $entity.attributes.size()),#else#end

#end
#end
                  };
                } else {
                    return false;
                }
            });
    };

    /**
     * Deletes an entity using its Id / Primary Key
     * @param $fn.argumentsList($entity.keyAttributes)
     * returns database deletion status
     */
    deleteById($fn.argumentsList($entity.keyAttributes)) {
		let sqlParams = {
			$sqlParamsAttribs
		};
        return this.genericDao.delete(sqlParams);
    };

    /**
     * Deletes an entity using the entity
     * @param ${entity.name}
     * returns database deletion status
     */
    delete(${entity.name}) {
        let sqlParams = {
 			$sqlPrimaryKeyParams
        };
        return this.genericDao.delete(sqlParams);
    };

    /**
     * Returns true if an entity exists with the given Id / Primary Key
     * @param $fn.argumentsList($entity.keyAttributes)
     * returns database entry existence status (true/false)
     */
    existsById($fn.argumentsList($entity.keyAttributes)) {
		let sqlParams = {
			$sqlParamsAttribs
		};
        return this.genericDao.existsOne(sqlParams);
    };

    /**
     * Returns true if an entity exists using the entity
     * @param ${entity.name}
     * returns database entry existence status (true/false)
     */
    exists(${entity.name}) {
        let sqlParams = {
            $sqlPrimaryKeyParams
        };
        return this.genericDao.existsOne(sqlParams);
    };
};